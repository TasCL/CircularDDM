# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

besselzero <- function(nu, k, kind) {
    .Call('_CircularDDM_besselzero', PACKAGE = 'CircularDDM', nu, k, kind)
}

dhamana <- function(RT, a, t0, sigma, k) {
    .Call('_CircularDDM_dhamana', PACKAGE = 'CircularDDM', RT, a, t0, sigma, k)
}

dcircle <- function(x, a, mu1, mu2, t0, sigma, k) {
    .Call('_CircularDDM_dcircle', PACKAGE = 'CircularDDM', x, a, mu1, mu2, t0, sigma, k)
}

rcircle <- function(n, a, mu1, mu2, t0, sigma, k, lower, upper, nth) {
    .Call('_CircularDDM_rcircle', PACKAGE = 'CircularDDM', n, a, mu1, mu2, t0, sigma, k, lower, upper, nth)
}

convDrift <- function(mean_v, mag2xy) {
    .Call('_CircularDDM_convDrift', PACKAGE = 'CircularDDM', mean_v, mag2xy)
}

#' Generate random deviates from a von Mises distribution
#'
#' This function generates random numbers in radian unit from a von Mises
#' distribution using the location (ie mean) parameter, mu and the
#' concentration (ie precision) parameter kappa.
#'
#' A random number for a circular normal distribution has the form:\cr
#' \deqn{f(theta; mu, kappa) = 1 / (2*pi*I0(kappa)) * exp(kappa*cos(theta-mu))}
#' theta is between 0 and 2*pi.
#'
#' \code{I0(kappa)} in the normalizing constant is the modified Bessel
#' function of the first kind and order zero.
#'
#' @param n number of observations. Must be a scalar.
#' @param mu mean direction of the distribution. Must be a scalar.
#' @param kappa concentration parameter. That is, the kappa. A positive value
#' for the concentration parameter of the distribution. Must be a scalar.
#'
#' @return a column vector
#' @examples
#' n  <- 1e2
#' mu <- 0
#' k  <- 10
#'
#' \dontrun{
#' vm1 <- circular:::RvonmisesRad(n, mu, k)
#' vm2 <- rvm(n, mu, k)
#' vm3 <- circular:::conversion.circular(circular:::circular(vm1))
#' vm4 <- circular:::conversion.circular(circular:::circular(vm2))
#' plot(vm3)
#' plot(vm4)
#' }
#' @export
rvm <- function(n, mu, kappa) {
    .Call('_CircularDDM_rvm', PACKAGE = 'CircularDDM', n, mu, kappa)
}

#' The Circular Decision-diffusion Distribution
#'
#' Generate random deviates from a circular decision-diffusion
#' model, using parameters, a, vx, vy, t0, and s. \code{rcddm1} is
#' canonical form of the random number generator for the circular
#' decision-diffusion model. \code{rcddm2} is an extension, allowing one to
#' supply a threshold vector, an angle vector, a starting point matrix
#' [xPos, yPos] and a non-decision time. The angle vector carries the
#' information of the drift magnitude and the drift direction.
#'
#' @param n numbers of observation.
#' @param a decision threshold. Must be a scalar.
#' @param mu1 x axis drift rate. This must be a scalar.
#' @param mu2 y axis drift rate. This must must be a scalar.
#' @param t0 non-decision time. This must be a scalar.
#' @param sigma square root of the diffusion coefficient. This is the
#' within-trial, moment-to-moment, standard deviation. This must be a scalar.
#' @param stepSize the size of a random walk step.
#' @param stepTime the unit time for a random walk step.
#' @param angle an angle vector, allowing one to supply a vector of randomly
#' drawn numbers from any distributions.
#' @param threshold a threshold vector.
#' @param sp a starting point matrix.  First column must be the x coordinate
#' of the starting point and the second column must be the y coordinate of
#' the starting point. Each row is a random number.
#'
#' @return a n x 2 matrix with two columns: RTs and angles.
#' @references Smith, P. L. (2016). Diffusion Theory of Decision Making in
#' Continuous Report, Psychological Review, 123 (4), 425--451.
#' @examples
#' ## rcddm1 example
#' den  <- rcddm1(1024, a = 2, mu1 = 1.5, mu2 = 1.25, t0 = 0.25, sigma = 1);
#' par(mfrow = c(1, 2))
#' hist(den[,1], breaks = "fd", xlab="RT (s)",  main="")
#' hist(den[,2], breaks = "fd", xlab="Angle (Rad)", main="")
#'
#' ## rcddm2 example
#' t0 <- .25
#' threshold <- runif(10, 0, 2)
#' angle <- rvm(1e3, 0, 10)
#' startpoint <- cbind(runif(10, 0, 1), runif(10, 0,1))
#' den  <- rcddm2_internal(1e3, threshold, angle, startpoint, t0)
#' head(den)
#'
#' ## If starting points only has one row, this is equilvalent to fixing
#' ## the starting points at constant values. This is because internally the
#' ## function will always use the first row when 'sp' is a row vector.
#' ## Similarly, one can apply the same trick on threshold and angle vectors.
#' startpoint <- cbind(runif(1, 0, 1),  runif(1, 0,1));
#' den <- rcddm2_internal(1e3, threshold, angle, startpoint, t0)
#'
#' ## If the user enters a R's vector, which is not a matrix,
#' ## rcddm2 wrapper helps the user to convert it to a matrix (ie row vector)
#' ## Note this flexibility requires checking steps.
#' den <- rcddm2_internal(1e3, threshold, angle, startpoint, t0)
#'
#' @export
rcddm1 <- function(n, a, mu1, mu2, t0, sigma, stepSize = 1, stepTime = 1e-4) {
    .Call('_CircularDDM_rcddm1', PACKAGE = 'CircularDDM', n, a, mu1, mu2, t0, sigma, stepSize, stepTime)
}

#' @rdname rcddm1
#' @export
rcddm2_internal <- function(n, threshold, angle, sp, t0, stepSize = .1, stepTime = .005) {
    .Call('_CircularDDM_rcddm2_internal', PACKAGE = 'CircularDDM', n, threshold, angle, sp, t0, stepSize, stepTime)
}

